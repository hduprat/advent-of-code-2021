/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package dev.duprat.aoc2021.day9

import dev.duprat.aoc2021.utils.*

typealias Basin = MutableSet<Point>

class Day9Scenario : Scenario {
    val heightmap: List<List<Short>>
    val lowPoints: MutableList<Point> = mutableListOf()
    val basins: MutableMap<Point, Basin>

    constructor() : super() {
        heightmap = lines.map { it.map { it.digitToInt().toShort() } }
        populateLowPoints()
        basins = lowPoints.associateWithTo(mutableMapOf()) { _ -> mutableSetOf() }
        populateBasins()
    }

    fun isLowPoint(x: Int, y: Int): Boolean {
        val height = heightmap[y][x]

        val leftHeight = heightmap[y].getOrNull(x - 1)
        if (leftHeight != null && leftHeight <= height) return false

        val rightHeight = heightmap[y].getOrNull(x + 1)
        if (rightHeight != null && rightHeight <= height) return false

        val topHeight = heightmap.getOrNull(y - 1)?.getOrNull(x)
        if (topHeight != null && topHeight <= height) return false

        val bottomHeight = heightmap.getOrNull(y + 1)?.getOrNull(x)
        if (bottomHeight != null && bottomHeight <= height) return false

        return true
    }

    fun populateLowPoints() {
        heightmap.forEachIndexed { y, row ->
            row.forEachIndexed { x, _ -> if (isLowPoint(x, y)) lowPoints.add(x to y) }
        }
    }

    fun evaluateRiskLevel(x: Int, y: Int): Int {
        return if (lowPoints.contains(x to y)) heightmap[y][x] + 1 else 0
    }

    fun evaluateTotalRiskLevel(): Int {
        return heightmap.foldIndexed(0) { y, sumY, elt ->
            sumY + elt.foldIndexed(0) { x, sumX, _ -> sumX + evaluateRiskLevel(x, y) }
        }
    }

    fun shouldPointBeAddedToBasin(point: Point, contiguousHeight: Short, basin: Basin): Boolean {
        val heightOrNull = heightmap.getOrNull(point.second)?.getOrNull(point.first)
        return when {
            basin.contains(point) -> false
            heightOrNull == null -> false
            heightOrNull == 9.toShort() -> false
            heightOrNull < contiguousHeight -> false
            else -> true
        }
    }

    fun extendBasin(basin: Basin, extendPoint: Point) {
        val (x, y) = extendPoint
        val height = heightmap[y][x]

        basin.add(extendPoint)

        if (shouldPointBeAddedToBasin(x - 1 to y, height, basin)) extendBasin(basin, x - 1 to y)
        if (shouldPointBeAddedToBasin(x + 1 to y, height, basin)) extendBasin(basin, x + 1 to y)
        if (shouldPointBeAddedToBasin(x to y - 1, height, basin)) extendBasin(basin, x to y - 1)
        if (shouldPointBeAddedToBasin(x to y + 1, height, basin)) extendBasin(basin, x to y + 1)
    }

    fun populateBasins() {
        basins.forEach { origin, basin -> extendBasin(basin, origin) }
    }

    fun multiplyThreeLargestBasinSizes(): Int {
        val basinSizes = basins.values.map { it.size }
        return basinSizes.sortedDescending().take(3).reduce { product, n -> product * n }
    }
}

fun main() {
    val scenario = Day9Scenario()
    println("Exercice 1")
    println(scenario.evaluateTotalRiskLevel())
    println("Exercice 2")
    println(scenario.multiplyThreeLargestBasinSizes())
}
