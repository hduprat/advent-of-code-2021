/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package dev.duprat.aoc2021.day15

import dev.duprat.aoc2021.utils.*

typealias Grid<T> = List<List<T>>

typealias MutableGrid<T> = List<MutableList<T>>

@kotlin.ExperimentalStdlibApi
class Day15Scenario : Scenario {
  val riskLevels: Grid<Int>
  val accumulatedRiskPathGrid: MutableGrid<Long?>

  fun loopBetween1And9(n: Int): Int {
    return if (n % 9 == 0) 9 else n % 9
  }

  fun buildRepeatedLine(line: String, repeats: Int, offset: Int): List<Int> {
    return buildList {
      for (i in 1..repeats) {
        addAll(line.map { loopBetween1And9(it.digitToInt() + (i - 1) + offset) })
      }
    }
  }

  constructor(tileRepeats: Int = 1) : super() {
    riskLevels =
        buildList {
          for (i in 1..tileRepeats) {
            addAll(lines.map { line -> buildRepeatedLine(line, tileRepeats, i - 1) })
          }
        }
    accumulatedRiskPathGrid = List(riskLevels.size) { MutableList(riskLevels[it].size) { null } }
  }

  fun scanRisks(): Boolean {
    var hasChanged = false

    accumulatedRiskPathGrid.forEachIndexed { y, column ->
      column.forEachIndexed { x, value ->
        if (x == 0 && y == 0) accumulatedRiskPathGrid[0][0] = 0
        else {
          val surroundingAccumulatedRisks = mutableListOf<Long?>()
          surroundingAccumulatedRisks.add(accumulatedRiskPathGrid.getOrNull(y - 1)?.getOrNull(x))
          surroundingAccumulatedRisks.add(accumulatedRiskPathGrid.getOrNull(y + 1)?.getOrNull(x))
          surroundingAccumulatedRisks.add(accumulatedRiskPathGrid.getOrNull(y)?.getOrNull(x - 1))
          surroundingAccumulatedRisks.add(accumulatedRiskPathGrid.getOrNull(y)?.getOrNull(x + 1))

          val newValue = surroundingAccumulatedRisks.filterNotNull().minOrNull()
          if (newValue != null) {
            if (value == null || value > riskLevels[y][x] + newValue) {
              accumulatedRiskPathGrid[y][x] = (riskLevels[y][x] + newValue)
              hasChanged = true
            }
          }
        }
      }
    }

    return hasChanged
  }

  fun computeLowestRisk(): Long {
    var i = 0
    while (scanRisks() && i < 150) {
      i++
    }
    println("It stopped changing after $i loops")
    return accumulatedRiskPathGrid.last().last() ?: -1
  }
}

@kotlin.ExperimentalStdlibApi
fun main() {
  println("Exercice 1")
  val scenario = Day15Scenario()
  println(scenario.computeLowestRisk())
  println("Exercice 2")
  val scenario5 = Day15Scenario(5)
  println(scenario5.computeLowestRisk())
}
