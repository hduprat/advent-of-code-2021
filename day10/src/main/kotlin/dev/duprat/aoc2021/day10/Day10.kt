/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package dev.duprat.aoc2021.day10

import dev.duprat.aoc2021.utils.*

class CorruptedCharError : Error {
    val character: Char
    constructor(char: Char) : super("Corrupted character found: $char") {
        character = char
    }
}

class IncorrectOpeningChar : Error {
    val character: Char
    constructor(char: Char) : super("$char is not an opening character") {
        character = char
    }
}

class Day10Scenario : Scenario {
    val openingChars = arrayOf('(', '[', '{', '<')
    val closingChars = arrayOf(')', ']', '}', '>')
    val corruptionScores = arrayOf(3, 57, 1197, 25137)

    constructor() : super() {}

    fun getClosingCharFor(character: Char): Char {
        val index = openingChars.indexOf(character)
        if (index == -1) throw IncorrectOpeningChar(character)
        return closingChars[index]
    }

    fun traverseChunk(line: String, openingIndex: Int): Int {
        var i = openingIndex
        val openingChar = line[i]
        val closingChar = closingChars[openingChars.indexOf(openingChar)]

        i++
        while (i < line.length && line[i] != closingChar) {
            if (openingChars.contains(line[i])) {
                i = traverseChunk(line, i)
                i++
            } else throw CorruptedCharError(line[i])
        }

        return i
    }

    fun getFirstCorruptedCharacter(line: String): Char? {
        try {
            traverseChunk(line, 0)
        } catch (error: CorruptedCharError) {
            return error.character
        }

        return null
    }

    fun computeCorruptionScore(): Int {
        return lines.sumOf {
            val corruptedChar = getFirstCorruptedCharacter(it)
            if (corruptedChar == null) 0 else corruptionScores[closingChars.indexOf(corruptedChar)]
        }
    }

    fun completeLine(line: String): String {
        var incompleteOpenedChunks = ""
        line.forEach {
            when {
                it in openingChars -> incompleteOpenedChunks += it
                it in closingChars -> {
                    if (getClosingCharFor(incompleteOpenedChunks.last()) == it)
                            incompleteOpenedChunks = incompleteOpenedChunks.dropLast(1)
                }
            }
        }

        return incompleteOpenedChunks.map { getClosingCharFor(it) }.reversed().joinToString("")
    }

    fun computeIncompletionScore(line: String): Long {
        val incompletionString = completeLine(line)
        return incompletionString.fold(0) { score, elt ->
            5 * score + closingChars.indexOf(elt) + 1
        }
    }

    fun computeTotalIncompletionScore(): Long {
        val scores =
                lines
                        .filter { getFirstCorruptedCharacter(it) == null }
                        .map { computeIncompletionScore(it) }
                        .sorted()
        return scores[(scores.size - 1) / 2]
    }
}

fun main() {
    val scenario = Day10Scenario()
    println("Exercice 1")
    println(scenario.computeCorruptionScore())
    println("Exercice 2")
    println(scenario.computeTotalIncompletionScore())
}
